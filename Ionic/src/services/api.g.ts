/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.9.0.0 (NJsonSchema v9.7.3.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

export const API_BASE_URL = new OpaqueToken('API_BASE_URL');

export interface IAnClient {
    /**
     * Sendet eine Authentifizierungsanfrage an den Server [AllowAnonymous]
     * @credentials Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return Returns nothing
     */
    authenticate(credentials: CredentialDto): Observable<AuthResponse>;
    /**
     * Sendet eine RefreshToken Abfrage an den Server [AllowAnonymous]
     * @refreshtokenparameter Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return AuthResponse
     */
    refreshtoken(refreshtokenparameter: RefreshTokenDto): Observable<AuthResponse>;
    /**
     * Einen Benutzer registrieren [AllowAnonymous]
     * @registerDto Registrierungsinformationen
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Bestätigungslink.
     */
    registerUser(registerDto: RegisterDto): Observable<RegisterResponse>;
    /**
     * Eine Benutzerregistrierung bestätigen [AllowAnonymous]
     * @id Userid
     * @cnf Confirmationtoken
     * @return Die Operation war erfolgreich.
     */
    confirmRegister(id: string, cnf: string): Observable<ConfirmResponse>;
    /**
     * Passwort wiederherstellen [AllowAnonymous]
     * @recoverPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Passwortresetcode.
     */
    recoverPassword(recoverPasswordParams: RecoverPasswordParams): Observable<RecoverPasswordResponse>;
    /**
     * Abfrage des Usernamens [AllowAnonymous]
     * @recoverUsernameParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit seinem Benutzernamen.
     */
    recoverUsername(recoverUsernameParams: RecoverUsernameParams): Observable<RecoverUsernameResponse>;
    /**
     * Ein Benutzer setzt ein neues Passwort [AllowAnonymous]
     * @setPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich.
     */
    setPassword(setPasswordParams: SetPasswordParams): Observable<SetPasswordResponse>;
    /**
     * Abfrage aller Profile
     * @return Die Operation war erfolgreich.
     */
    getProfiles(): Observable<GetProfilesResponse>;
    /**
     * Abfrage des eigenen Profils
     * @return Die Operation war erfolgreich.
     */
    getMyProfile(): Observable<GetProfileResponse>;
    /**
     * Abfrage eines Benutzerprofiles
     * @userid User Id
     * @return Die Operation war erfolgreich.
     */
    getProfile(userid: string): Observable<GetProfileResponse>;
    /**
     * Get the list of users [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns nothing
     */
    adminGetUsers(): Observable<UsersDto>;
    /**
     * Get the list of sessions [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns nothing
     */
    adminGetSessions(): Observable<SessionsDto>;
}

@Injectable()
export class AnClient implements IAnClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:3000/api/v1";
    }

    /**
     * Sendet eine Authentifizierungsanfrage an den Server [AllowAnonymous]
     * @credentials Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return Returns nothing
     */
    authenticate(credentials: CredentialDto): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(credentials);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAuthenticate(response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<AuthResponse>><any>Observable.throw(response_);
        });
    }

    protected processAuthenticate(response: Response): Observable<AuthResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthResponse.fromJS(resultData200) : new AuthResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Sendet eine RefreshToken Abfrage an den Server [AllowAnonymous]
     * @refreshtokenparameter Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return AuthResponse
     */
    refreshtoken(refreshtokenparameter: RefreshTokenDto): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/refreshtoken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshtokenparameter);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefreshtoken(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefreshtoken(response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<AuthResponse>><any>Observable.throw(response_);
        });
    }

    protected processRefreshtoken(response: Response): Observable<AuthResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? AuthResponse.fromJS(resultData) : new AuthResponse();
            return Observable.of(result);
        }
    }

    /**
     * Einen Benutzer registrieren [AllowAnonymous]
     * @registerDto Registrierungsinformationen
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Bestätigungslink.
     */
    registerUser(registerDto: RegisterDto): Observable<RegisterResponse> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerDto);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRegisterUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRegisterUser(response_);
                } catch (e) {
                    return <Observable<RegisterResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegisterResponse>><any>Observable.throw(response_);
        });
    }

    protected processRegisterUser(response: Response): Observable<RegisterResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterResponse.fromJS(resultData200) : new RegisterResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Eine Benutzerregistrierung bestätigen [AllowAnonymous]
     * @id Userid
     * @cnf Confirmationtoken
     * @return Die Operation war erfolgreich.
     */
    confirmRegister(id: string, cnf: string): Observable<ConfirmResponse> {
        let url_ = this.baseUrl + "/confirm?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (cnf === undefined || cnf === null)
            throw new Error("The parameter 'cnf' must be defined and cannot be null.");
        else
            url_ += "cnf=" + encodeURIComponent("" + cnf) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processConfirmRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processConfirmRegister(response_);
                } catch (e) {
                    return <Observable<ConfirmResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ConfirmResponse>><any>Observable.throw(response_);
        });
    }

    protected processConfirmRegister(response: Response): Observable<ConfirmResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ConfirmResponse.fromJS(resultData200) : new ConfirmResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Passwort wiederherstellen [AllowAnonymous]
     * @recoverPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Passwortresetcode.
     */
    recoverPassword(recoverPasswordParams: RecoverPasswordParams): Observable<RecoverPasswordResponse> {
        let url_ = this.baseUrl + "/recoverPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recoverPasswordParams);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRecoverPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRecoverPassword(response_);
                } catch (e) {
                    return <Observable<RecoverPasswordResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<RecoverPasswordResponse>><any>Observable.throw(response_);
        });
    }

    protected processRecoverPassword(response: Response): Observable<RecoverPasswordResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecoverPasswordResponse.fromJS(resultData200) : new RecoverPasswordResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Abfrage des Usernamens [AllowAnonymous]
     * @recoverUsernameParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit seinem Benutzernamen.
     */
    recoverUsername(recoverUsernameParams: RecoverUsernameParams): Observable<RecoverUsernameResponse> {
        let url_ = this.baseUrl + "/recoverUsername";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recoverUsernameParams);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRecoverUsername(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRecoverUsername(response_);
                } catch (e) {
                    return <Observable<RecoverUsernameResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<RecoverUsernameResponse>><any>Observable.throw(response_);
        });
    }

    protected processRecoverUsername(response: Response): Observable<RecoverUsernameResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecoverUsernameResponse.fromJS(resultData200) : new RecoverUsernameResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Ein Benutzer setzt ein neues Passwort [AllowAnonymous]
     * @setPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich.
     */
    setPassword(setPasswordParams: SetPasswordParams): Observable<SetPasswordResponse> {
        let url_ = this.baseUrl + "/setPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setPasswordParams);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSetPassword(response_);
                } catch (e) {
                    return <Observable<SetPasswordResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<SetPasswordResponse>><any>Observable.throw(response_);
        });
    }

    protected processSetPassword(response: Response): Observable<SetPasswordResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SetPasswordResponse.fromJS(resultData200) : new SetPasswordResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Abfrage aller Profile
     * @return Die Operation war erfolgreich.
     */
    getProfiles(): Observable<GetProfilesResponse> {
        let url_ = this.baseUrl + "/profiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetProfiles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProfiles(response_);
                } catch (e) {
                    return <Observable<GetProfilesResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfilesResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetProfiles(response: Response): Observable<GetProfilesResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilesResponse.fromJS(resultData200) : new GetProfilesResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Abfrage des eigenen Profils
     * @return Die Operation war erfolgreich.
     */
    getMyProfile(): Observable<GetProfileResponse> {
        let url_ = this.baseUrl + "/profiles/myprofile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetMyProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetMyProfile(response_);
                } catch (e) {
                    return <Observable<GetProfileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfileResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetMyProfile(response: Response): Observable<GetProfileResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfileResponse.fromJS(resultData200) : new GetProfileResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Abfrage eines Benutzerprofiles
     * @userid User Id
     * @return Die Operation war erfolgreich.
     */
    getProfile(userid: string): Observable<GetProfileResponse> {
        let url_ = this.baseUrl + "/profiles/{userid}";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProfile(response_);
                } catch (e) {
                    return <Observable<GetProfileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfileResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetProfile(response: Response): Observable<GetProfileResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfileResponse.fromJS(resultData200) : new GetProfileResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Get the list of users [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns nothing
     */
    adminGetUsers(): Observable<UsersDto> {
        let url_ = this.baseUrl + "/admin/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAdminGetUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAdminGetUsers(response_);
                } catch (e) {
                    return <Observable<UsersDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UsersDto>><any>Observable.throw(response_);
        });
    }

    protected processAdminGetUsers(response: Response): Observable<UsersDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersDto.fromJS(resultData200) : new UsersDto();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Get the list of sessions [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns nothing
     */
    adminGetSessions(): Observable<SessionsDto> {
        let url_ = this.baseUrl + "/admin/sessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAdminGetSessions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAdminGetSessions(response_);
                } catch (e) {
                    return <Observable<SessionsDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SessionsDto>><any>Observable.throw(response_);
        });
    }

    protected processAdminGetSessions(response: Response): Observable<SessionsDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SessionsDto.fromJS(resultData200) : new SessionsDto();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }
}

export class AuthResponse implements IAuthResponse {
    status?: OpResult | undefined;
    /** The token will be valid for validFor seconds */
    validFor?: number | undefined;
    /** The user id */
    id?: string | undefined;
    /** Ein Authentifizierungstoken mit dem alle folgenden Aufrufe authentifiziert werden. */
    token?: string | undefined;
    /** Ein RefreshToken mit dem der token erneuert werden kann. */
    refreshtoken?: string | undefined;

    constructor(data?: IAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.validFor = data["validFor"];
            this.id = data["id"];
            this.token = data["token"];
            this.refreshtoken = data["refreshtoken"];
        }
    }

    static fromJS(data: any): AuthResponse {
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["validFor"] = this.validFor;
        data["id"] = this.id;
        data["token"] = this.token;
        data["refreshtoken"] = this.refreshtoken;
        return data; 
    }
}

export interface IAuthResponse {
    status?: OpResult | undefined;
    /** The token will be valid for validFor seconds */
    validFor?: number | undefined;
    /** The user id */
    id?: string | undefined;
    /** Ein Authentifizierungstoken mit dem alle folgenden Aufrufe authentifiziert werden. */
    token?: string | undefined;
    /** Ein RefreshToken mit dem der token erneuert werden kann. */
    refreshtoken?: string | undefined;
}

export class CredentialDto implements ICredentialDto {
    /** Der Client-Typ 'web', 'ionic' */
    client_type?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: ICredentialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.client_type = data["client_type"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CredentialDto {
        let result = new CredentialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["client_type"] = this.client_type;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ICredentialDto {
    /** Der Client-Typ 'web', 'ionic' */
    client_type?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class RefreshTokenDto implements IRefreshTokenDto {
    /** Der Refresh Token */
    refresh_token?: string | undefined;

    constructor(data?: IRefreshTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.refresh_token = data["refresh_token"];
        }
    }

    static fromJS(data: any): RefreshTokenDto {
        let result = new RefreshTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refresh_token"] = this.refresh_token;
        return data; 
    }
}

export interface IRefreshTokenDto {
    /** Der Refresh Token */
    refresh_token?: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    /** Der Vorname, 1 .. 80 Zeichen */
    firstname?: string | undefined;
    /** Der Name, 1 .. 80 Zeichen */
    name?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstname = data["firstname"];
            this.name = data["name"];
            this.email = data["email"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): RegisterDto {
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstname"] = this.firstname;
        data["name"] = this.name;
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IRegisterDto {
    /** Der Vorname, 1 .. 80 Zeichen */
    firstname?: string | undefined;
    /** Der Name, 1 .. 80 Zeichen */
    name?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class RegisterResponse implements IRegisterResponse {
    status?: OpResult | undefined;

    constructor(data?: IRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterResponse {
        let result = new RegisterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterResponse {
    status?: OpResult | undefined;
}

export class ConfirmResponse implements IConfirmResponse {
    status?: OpResult | undefined;

    constructor(data?: IConfirmResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConfirmResponse {
        let result = new ConfirmResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IConfirmResponse {
    status?: OpResult | undefined;
}

export class RecoverPasswordParams implements IRecoverPasswordParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;

    constructor(data?: IRecoverPasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.username = data["username"];
        }
    }

    static fromJS(data: any): RecoverPasswordParams {
        let result = new RecoverPasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["username"] = this.username;
        return data; 
    }
}

export interface IRecoverPasswordParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
}

export class RecoverUsernameParams implements IRecoverUsernameParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;

    constructor(data?: IRecoverUsernameParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
        }
    }

    static fromJS(data: any): RecoverUsernameParams {
        let result = new RecoverUsernameParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IRecoverUsernameParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
}

export class RecoverPasswordResponse implements IRecoverPasswordResponse {
    status?: OpResult | undefined;

    constructor(data?: IRecoverPasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecoverPasswordResponse {
        let result = new RecoverPasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRecoverPasswordResponse {
    status?: OpResult | undefined;
}

export class RecoverUsernameResponse implements IRecoverUsernameResponse {
    status?: OpResult | undefined;

    constructor(data?: IRecoverUsernameResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecoverUsernameResponse {
        let result = new RecoverUsernameResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRecoverUsernameResponse {
    status?: OpResult | undefined;
}

export class SetPasswordParams implements ISetPasswordParams {
    /** Der Passwortresetcode. */
    code?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: ISetPasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): SetPasswordParams {
        let result = new SetPasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ISetPasswordParams {
    /** Der Passwortresetcode. */
    code?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class SetPasswordResponse implements ISetPasswordResponse {
    status?: OpResult | undefined;

    constructor(data?: ISetPasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SetPasswordResponse {
        let result = new SetPasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISetPasswordResponse {
    status?: OpResult | undefined;
}

export class GetProfilesResponse implements IGetProfilesResponse {
    status?: OpResult | undefined;

    constructor(data?: IGetProfilesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetProfilesResponse {
        let result = new GetProfilesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetProfilesResponse {
    status?: OpResult | undefined;
}

export class GetProfileResponse implements IGetProfileResponse {
    status?: OpResult | undefined;

    constructor(data?: IGetProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetProfileResponse {
        let result = new GetProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetProfileResponse {
    status?: OpResult | undefined;
}

export class UsersDto implements IUsersDto {
    users?: UserDto[] | undefined;

    constructor(data?: IUsersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["users"] && data["users"].constructor === Array) {
                this.users = [];
                for (let item of data["users"])
                    this.users.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersDto {
        let result = new UsersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.users && this.users.constructor === Array) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUsersDto {
    users?: UserDto[] | undefined;
}

export class UserDto implements IUserDto {
    /** Then user id */
    id?: string | undefined;
    /** The first name of user */
    firstName?: string | undefined;
    /** The last name of user */
    lastName?: string | undefined;
    /** The email of the user */
    email?: string | undefined;
    /** The confirmed status of the user registration */
    emailConfirmed?: boolean | undefined;
    /** The number of failed access attempts */
    accessFailedCount?: number | undefined;
    roleNames?: RoleDto[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.emailConfirmed = data["emailConfirmed"];
            this.accessFailedCount = data["accessFailedCount"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["accessFailedCount"] = this.accessFailedCount;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserDto {
    /** Then user id */
    id?: string | undefined;
    /** The first name of user */
    firstName?: string | undefined;
    /** The last name of user */
    lastName?: string | undefined;
    /** The email of the user */
    email?: string | undefined;
    /** The confirmed status of the user registration */
    emailConfirmed?: boolean | undefined;
    /** The number of failed access attempts */
    accessFailedCount?: number | undefined;
    roleNames?: RoleDto[] | undefined;
}

export class RoleDto implements IRoleDto {
    /** Name of role */
    name?: string | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): RoleDto {
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IRoleDto {
    /** Name of role */
    name?: string | undefined;
}

export class SessionsDto implements ISessionsDto {
    sessions?: SessionDto[] | undefined;

    constructor(data?: ISessionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["sessions"] && data["sessions"].constructor === Array) {
                this.sessions = [];
                for (let item of data["sessions"])
                    this.sessions.push(SessionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SessionsDto {
        let result = new SessionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.sessions && this.sessions.constructor === Array) {
            data["sessions"] = [];
            for (let item of this.sessions)
                data["sessions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISessionsDto {
    sessions?: SessionDto[] | undefined;
}

export class SessionDto implements ISessionDto {
    /** Then sessions id */
    id?: string | undefined;
    /** The userid associated with the session */
    userid?: string | undefined;
    /** the email of the user */
    email?: string | undefined;
    /** The timestamp of the creation */
    created?: string | undefined;
    /** True if the session is stopped */
    isStop?: boolean | undefined;

    constructor(data?: ISessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userid = data["userid"];
            this.email = data["email"];
            this.created = data["created"];
            this.isStop = data["isStop"];
        }
    }

    static fromJS(data: any): SessionDto {
        let result = new SessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userid"] = this.userid;
        data["email"] = this.email;
        data["created"] = this.created;
        data["isStop"] = this.isStop;
        return data; 
    }
}

export interface ISessionDto {
    /** Then sessions id */
    id?: string | undefined;
    /** The userid associated with the session */
    userid?: string | undefined;
    /** the email of the user */
    email?: string | undefined;
    /** The timestamp of the creation */
    created?: string | undefined;
    /** True if the session is stopped */
    isStop?: boolean | undefined;
}

export class OpResult implements IOpResult {
    /** True wenn die Operation erfolgreich war */
    success?: boolean | undefined;
    /** Eine Text-Meldung */
    result?: string | undefined;

    constructor(data?: IOpResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            this.result = data["result"];
        }
    }

    static fromJS(data: any): OpResult {
        let result = new OpResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["result"] = this.result;
        return data; 
    }
}

export interface IOpResult {
    /** True wenn die Operation erfolgreich war */
    success?: boolean | undefined;
    /** Eine Text-Meldung */
    result?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
	headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
		super();

        this.message = message;
        this.status = status;
        this.response = response;
		this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => { 
        let reader = new FileReader(); 
        reader.onload = function() { 
            observer.next(this.result);
            observer.complete();
        }
        reader.readAsText(blob); 
    });
}